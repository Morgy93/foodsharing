#!/bin/bash

export FS_ENV=dev
export CURRENT_USER=$(id -u):$(id -g)

# set -o errexit tells the shell to exit as soon as a command exits with non-zero status, i.e. fails
set -o errexit

dir=$(dirname "$0")

# source runs the content of the argument as if it was here (without launching a subshell!)
# inc.sh defines basic functions, mainly to run commands in containers
# shellcheck source=./inc.sh
source "$dir"/inc.sh

echo "---------------------"
echo ">>> Bringing up containers ..."
# dc is defined in inc.sh and starts docker-compose with following arguments
# up starts the container, -d: run in background as a deamon
dc up -d

echo "---------------------"
echo ">>> Create folder structur ..."
"$dir"/mkdirs

echo "---------------------"
echo ">>> Create Volumes ..."
run-in-container-asroot client "chown -R $CURRENT_USER /home/node/app/client/node_modules"
run-in-container-asroot chat "chown -R $CURRENT_USER node_modules"

echo "---------------------"
echo ">>> Running composer install ..."
# exec-in-container is defined in inc.sh
exec-in-container app composer install
exec-in-container app rm --recursive --force cache/.views-cache cache/di-cache.php

echo "---------------------"
echo ">>> Waiting for database ..."
wait-for-mysql

echo "---------------------"
echo ">>> Creating DB ..."
createdb foodsharing

echo "---------------------"
echo ">>> Migrating DB ..."
migratedb

echo "---------------------"
echo ">>> Reset (clear) cache ..."
# this helps to reduce some cache permissions errors
exec-in-container app bin/console cache:clear

echo "---------------------"
echo ">>> Waiting for assets to be generated ..."
wait-for-assets
exec-in-container app bin/console assets:install

echo "---------------------"
echo
echo
echo " Before you run the full Webpage, run ./scripts/seed to initialize the database with some fake data."
echo
getEnvUrls
output-message
